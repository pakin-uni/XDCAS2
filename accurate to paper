class C2fEMA(nn.Module):
    def __init__(self, c1, c2, n=1, shortcut=False, g=1, e=0.5):
        super().__init__()
        self.c = int(c2 * e)
        self.cv1 = Conv(c1, 2 * self.c, 1, 1)  # Initial Conv
        self.ema = EMA(self.c)                # EMA after split
        self.m = nn.ModuleList(
            Bottleneck(self.c, self.c, shortcut, g, k=((3, 3), (3, 3)), e=1.0)
            for _ in range(n)
        )
        self.cv2 = Conv((2 + n) * self.c, c2, 1)  # Final Conv
    def forward(self, x):
        y = list(self.cv1(x).chunk(2, 1))  # Split into [y0, y1]
        y[1] = self.ema(y[1])              # Apply EMA to second part only
        y.extend(m(y[-1]) for m in self.m) # Bottlenecks process updated y[1]
        return self.cv2(torch.cat(y, 1))

    def forward_split(self, x):
        y = list(self.cv1(x).split((self.c, self.c), 1))
        y[1] = self.ema(y[1])              # Apply EMA to second part
        y.extend(m(y[-1]) for m in self.m)
        return self.cv2(torch.cat(y, 1))
